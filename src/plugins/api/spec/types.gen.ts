// This file is auto-generated by @hey-api/openapi-ts
/* eslint-disable  @typescript-eslint/no-unused-vars */

export type AbstractFilter = {
  filter?: "abstract";
  comp?: string | null;
  size?: number | null;
  empty?: boolean | null;
};

export type AcademicAuthorModel = {
  name: string;
  surname_initials?: string | null;
  email?: string | null;
  orcid?: string | null;
  scopus_id?: string | null;
  openalex_id?: string | null;
  s2_id?: string | null;
  affiliations?: Array<AffiliationModel> | null;
};

export type AcademicItemImport = {
  sources: Array<string>;
  kind?: "academic";
};

/**
 * Corresponds to db.schema.items.academic.AcademicItem
 */
export type AcademicItemModel = {
  item_id?: string | null;
  project_id?: string | null;
  type?: ItemType;
  time_edited?: string | null;
  text?: string | null;
  doi?: string | null;
  wos_id?: string | null;
  scopus_id?: string | null;
  openalex_id?: string | null;
  s2_id?: string | null;
  pubmed_id?: string | null;
  dimensions_id?: string | null;
  title?: string | null;
  title_slug?: string | null;
  publication_year?: number | null;
  source?: string | null;
  keywords?: Array<string> | null;
  authors?: Array<AcademicAuthorModel> | null;
  meta?: {
    [key: string]: unknown;
  } | null;
};

export type AcademicItemVariantModel = {
  item_variant_id: string;
  item_id: string;
  import_id?: string | null;
  import_revision?: number | null;
  doi?: string | null;
  wos_id?: string | null;
  scopus_id?: string | null;
  openalex_id?: string | null;
  s2_id?: string | null;
  pubmed_id?: string | null;
  dimensions_id?: string | null;
  title?: string | null;
  publication_year?: number | null;
  source?: string | null;
  keywords?: Array<string> | null;
  authors?: Array<AcademicAuthorModel> | null;
  text?: string | null;
  meta?: {
    [key: string]: unknown;
  } | null;
};

export type AffiliationModel = {
  name: string;
  country?: string | null;
  openalex_id?: string | null;
  s2_id?: string | null;
};

export type AnnotatedItem = {
  scheme: AnnotationSchemeModel;
  assignment: AssignmentModel;
};

export type AnnotationFilter = {
  filter?: "annotation";
  incl: boolean;
  scopes?: Array<string> | null;
  scheme?: string | null;
};

export type AnnotationItem = {
  scheme: AnnotationSchemeModel;
  assignment: AssignmentModel;
  scope: AssignmentScopeModel;
  item: TwitterItemModel | AcademicItemModel | LexisNexisItemModel | FullLexisNexisItemModel | GenericItemModel;
};

/**
 * Corresponds to db.models.annotations.Annotation
 *
 * Annotation holds the judgement of a User for a specific Item in the context of an AnnotationScheme
 * as a response to an Assignment.
 * Once an Annotation exists, the Assignment should be considered (partially) resolved.
 *
 * Note, that AnnotationScheme, User, and Item would be implicit by the Assignment.
 * However, for ease of use and in favour of fewer joins, this information is replicated here.
 *
 * The Annotation refers to an AnnotationSchemeLabel defined in an AnnotationScheme, which is referred to by its `key`.
 * If the scheme allows the user to make repeated annotations for the same Label (`key`),
 * an offset is defined in `repeat` (e.g. for primary technology is "natural tech", secondary is "forests").
 *
 * Note, that there is no database constraints on the completeness of an Assignment/AnnotationScheme.
 * The interface/backend code should be used to make sure, to either not allow partial fulfillment of an
 * AnnotationScheme or not display an Assignment as complete.
 */
export type AnnotationModel = {
  value_bool?: boolean | null;
  value_int?: number | null;
  value_float?: number | null;
  value_str?: string | null;
  multi_int?: Array<number> | null;
  annotation_id?: string | null;
  time_created?: string | null;
  time_updated?: string | null;
  assignment_id: string;
  user_id: string;
  item_id: string;
  annotation_scheme_id: string;
  snippet_id?: string | null;
  key: string;
  repeat?: number;
  parent?: string | null;
};

/**
 * Annotation Quality Trackers
 * Computing annotator agreements is a little too expensive to do on the fly. Hence, we capture different
 * quality metrics in this table; one row per assignment scope and label.
 */
export type AnnotationQualityModel = {
  annotation_quality_id?: string | null;
  project_id?: string | null;
  assignment_scope_id?: string | null;
  bot_annotation_metadata_id?: string | null;
  user_base?: string | null;
  annotations_base?: Array<Array<number> | null> | Array<boolean | null> | Array<number | null> | null;
  user_target?: string | null;
  annotations_target?: Array<boolean | null> | Array<number | null> | Array<Array<number> | null> | null;
  label_key?: string | null;
  label_value?: number | null;
  cohen?: number | null;
  fleiss?: number | null;
  randolph?: number | null;
  krippendorff?: number | null;
  pearson?: number | null;
  pearson_p?: number | null;
  kendall?: number | null;
  kendall_p?: number | null;
  spearman?: number | null;
  spearman_p?: number | null;
  precision?: number | null;
  recall?: number | null;
  f1?: number | null;
  multi_overlap_mean?: number | null;
  multi_overlap_median?: number | null;
  multi_overlap_std?: number | null;
  num_items?: number | null;
  num_overlap?: number | null;
  num_agree?: number | null;
  num_disagree?: number | null;
  perc_agree?: number | null;
  time_created?: string | null;
  time_updated?: string | null;
};

export type AnnotationSchemeInfo = {
  annotation_scheme_id?: string | null;
  project_id?: string | null;
  name: string;
  description?: string | null;
  inclusion_rule?: string | null;
  time_created?: string | null;
  time_updated?: string | null;
};

export type AnnotationSchemeLabel = {
  name: string;
  key: string;
  hint?: string | null;
  max_repeat?: number;
  required?: boolean;
  dropdown?: boolean;
  kind?: "bool" | "str" | "float" | "int" | "single" | "multi" | "intext";
  choices?: Array<AnnotationSchemeLabelChoice> | null;
  annotation?: AnnotationModel | null;
};

export type AnnotationSchemeLabelChoice = {
  name: string;
  hint?: string | null;
  value: number;
  children?: Array<AnnotationSchemeLabel> | null;
};

export type AnnotationSchemeLabelChoiceFlat = {
  name: string;
  hint?: string | null;
  value: number;
};

/**
 * Corresponds to db.models.annotations.AnnotationScheme
 *
 * AnnotationScheme defines the annotation scheme for a particular project.
 * Each project may have multiple AnnotationSchemes,
 * but projects cannot share the same scheme. In case they are technically the same,
 * the user would have to create a new copy of that scheme for a different project.
 *
 * The actual annotation scheme is defined as a list of labels (see schemas.annotations.AnnotationSchemeLabel).
 * The other fields pose as meta-data.
 */
export type AnnotationSchemeModel = {
  annotation_scheme_id?: string | null;
  project_id?: string | null;
  name: string;
  description?: string | null;
  inclusion_rule?: string | null;
  time_created?: string | null;
  time_updated?: string | null;
  labels: Array<AnnotationSchemeLabel>;
};

/**
 * Same as AnnotationSchemeModel but with flattened structure.
 */
export type AnnotationSchemeModelFlat = {
  annotation_scheme_id?: string | null;
  project_id?: string | null;
  name: string;
  description?: string | null;
  inclusion_rule?: string | null;
  time_created?: string | null;
  time_updated?: string | null;
  labels: Array<FlattenedAnnotationSchemeLabel>;
};

/**
 * Tracker for annotation statistics.
 * This includes the latest stopping criterion (buscar) metrics and more.
 *
 * You may have more than one tracker per project, for example for keeping track of different progresses.
 */
export type AnnotationTrackerModel = {
  annotation_tracking_id?: string | null;
  name: string;
  project_id: string;
  inclusion_rule: string;
  majority: boolean;
  n_items_total: number;
  batch_size: number;
  recall_target: number;
  source_ids?: Array<string> | null;
  labels?: Array<Array<number>> | null;
  recall?: Array<number | null> | null;
  buscar?: Array<unknown[]> | null;
  time_created?: string | null;
  time_updated?: string | null;
};

export type AnnotationValue = {
  value_bool?: boolean | null;
  value_int?: number | null;
  value_float?: number | null;
  value_str?: string | null;
  multi_int?: Array<number> | null;
};

export type AssignmentConfigLegacy = {
  config_type?: "LEGACY";
  legacy: {
    [key: string]: unknown;
  };
};

export type AssignmentConfigPriority = {
  users: {
    [key: string]: number;
  };
  overlaps: {
    [key: string]: number;
  };
  random_seed?: number;
  config_type?: "PRIORITY";
  priority_id: string;
  prio_offset: number;
};

export type AssignmentConfigRandom = {
  users: {
    [key: string]: number;
  };
  overlaps: {
    [key: string]: number;
  };
  random_seed?: number;
  config_type?: "RANDOM";
  nql: string;
  nql_parsed?:
    | FieldFilter
    | FieldFilters
    | LabelFilterMulti
    | LabelFilterBool
    | LabelFilterInt
    | AssignmentFilter
    | AnnotationFilter
    | AbstractFilter
    | ImportFilter
    | MetaFilterBool
    | MetaFilterInt
    | MetaFilterStr
    | SubQuery
    | null;
};

export type AssignmentCounts = {
  num_total: number;
  num_open: number;
  num_partial: number;
  num_full: number;
};

export type AssignmentEditInfo = {
  scope_id: string;
  scheme_id: string;
  item_id: string;
  user_id: string;
  order: number;
};

export type AssignmentFilter = {
  filter?: "assignment";
  mode: number;
  scopes?: Array<string> | null;
  scheme?: string | null;
};

export type AssignmentInfo = {
  user_id: string;
  username: string;
  order: number;
  assignment_id: string;
  status: AssignmentStatus;
  labels?: {
    [key: string]: Array<AssignmentInfoLabel>;
  } | null;
};

export type AssignmentInfoLabel = {
  repeat: number;
  value_int?: number | null;
  value_bool?: boolean | null;
  multi_ind?: Array<number> | null;
};

/**
 * Corresponds to db.models.annotations.Assignment
 *
 * Assignment is used to request a user/annotator (User) to annotate a particular item (BaseItem) in the database
 * following a pre-defined annotation scheme (AnnotationScheme).
 *
 * Each AnnotationScheme will have several Assignments.
 * Each User will "receive" several Assignments.
 * Each Item may have several Assignments (either in relation to different AnnotationSchemes or double-coding).
 * The Project is implicit by the AnnotationScheme.
 *
 * The most common use-cases are:
 * * Creating assignments in bulk at random (e.g. 3 users should annotate 50 documents each)
 * * Creating assignments one at a time based on a set of rules (e.g. for double-coding, defined order, bias, ...)
 * * Creating assignments in small batches or one-by-one in prioritised annotation settings
 */
export type AssignmentModel = {
  assignment_id?: string | null;
  assignment_scope_id: string;
  user_id: string;
  item_id: string;
  annotation_scheme_id: string;
  status: AssignmentStatus;
  order?: number | null;
};

export type AssignmentScopeEntry = {
  item_id: string;
  first_occurrence: number;
  identifier: number;
  assignments: Array<AssignmentInfo>;
};

/**
 * AssignmentScope can be used to logically group a set of Assignments.
 * For example, one may wish to re-use the same AnnotationScheme several times within a project
 * without copying it each time. It may also be used to logically group different scopes of
 * the annotation process, for example to make it clear that different subsets of a dataset
 * are to be annotated.
 * Logically, this should be viewed as a hierarchical organisation
 * AnnotationScheme -> [AssignmentScope] -> Assignment -> Annotation
 */
export type AssignmentScopeModel = {
  assignment_scope_id?: string | null;
  annotation_scheme_id: string;
  time_created?: string | null;
  name: string;
  description?: string | null;
  config?: AssignmentConfigRandom | AssignmentConfigPriority | AssignmentConfigLegacy | null;
};

export type AssignmentStatus = "FULL" | "PARTIAL" | "OPEN" | "INVALID";

export type AuthTokenModel = {
  token_id: string;
  username: string;
  time_created?: string | null;
  time_updated?: string | null;
  valid_till?: string | null;
};

export type BasicProjectStats = {
  num_items: number;
  num_imports: number;
  num_schemes: number;
  num_scopes: number;
  num_labels: number;
  num_labeled_items: number;
};

export type Body_login_for_access_token_api_login_token_post = {
  grant_type?: string | null;
  username: string;
  password: string;
  scope?: string;
  client_id?: string | null;
  client_secret?: string | null;
};

export type Body_news_mail_api_mail_news_post = {
  subject: string;
  body: string;
};

export type Body_save_resolved_annotations_api_annotations_config_resolve__put = {
  settings: BotMetaResolveBase;
  matrix: {
    [key: string]: {
      [key: string]: ResolutionCell;
    };
  };
};

export type Body_upload_file_api_pipes_artefacts_files_upload_post = {
  file: Blob | File;
};

export type Body_upload_files_api_pipes_artefacts_files_upload_many_post = {
  file: Array<Blob | File>;
};

export type BotAnnotationMetaDataBaseModel = {
  bot_annotation_metadata_id?: string | null;
  name: string;
  kind: BotKind;
  project_id: string;
  time_created?: string | null;
  time_updated?: string | null;
  assignment_scope_id?: string | null;
  annotation_scheme_id?: string | null;
};

export type BotAnnotationMetaDataModel = {
  bot_annotation_metadata_id?: string | null;
  name: string;
  kind: BotKind;
  project_id: string;
  time_created?: string | null;
  time_updated?: string | null;
  assignment_scope_id?: string | null;
  annotation_scheme_id?: string | null;
  meta?: BotMetaResolve | null;
};

export type BotAnnotationModel = {
  value_bool?: boolean | null;
  value_int?: number | null;
  value_float?: number | null;
  value_str?: string | null;
  multi_int?: Array<number> | null;
  bot_annotation_id?: string | null;
  bot_annotation_metadata_id?: string | null;
  time_created?: string | null;
  time_updated?: string | null;
  item_id: string;
  parent?: string | null;
  key?: string | null;
  repeat?: number;
  order?: number | null;
  confidence?: number | null;
};

export type BotAnnotationResolution = {
  bot_annotation_metadata_id?: string | null;
  name: string;
  kind: BotKind;
  project_id: string;
  time_created?: string | null;
  time_updated?: string | null;
  assignment_scope_id: string;
  annotation_scheme_id: string;
  meta: BotMetaResolve;
};

export type BotKind = "CLASSIFICATION" | "RULES" | "TOPICS" | "RESOLVE" | "SCRIPT";

export type BotMetaInfo = {
  bot_annotation_metadata_id?: string | null;
  name: string;
  kind: BotKind;
  project_id: string;
  time_created?: string | null;
  time_updated?: string | null;
  assignment_scope_id?: string | null;
  annotation_scheme_id?: string | null;
  num_annotations: number;
  num_annotated_items: number;
};

export type BotMetaResolve = {
  algorithm: ResolutionMethod;
  ignore_hierarchy: boolean;
  ignore_repeat: boolean;
  snapshot: Array<SnapshotEntry>;
  resolutions: Array<ResolutionSnapshotEntry>;
};

export type BotMetaResolveBase = {
  algorithm: ResolutionMethod;
  ignore_hierarchy: boolean;
  ignore_repeat: boolean;
};

export type BulkAddPayload = {
  user_id: string;
  scope_id: string;
  scheme_id: string;
  item_ids: Array<string>;
};

export type Cashtag = {
  start: number;
  end: number;
  tag: string;
};

export type ClimateBERTModel = {
  max_len?: number;
  train_split?: number;
  n_epochs?: number;
  batch_size_predict?: number;
  batch_size_train?: number;
  batch_size_eval?: number;
  warmup_steps?: number;
  weight_decay?: number;
  logging_steps?: number;
  eval_strategy?: string;
  eval_steps?: number;
  conf?: "CLIMBERT";
  model?: string;
};

/**
 * Flattened and reduced version of the context_annotation object
 * https://developer.twitter.com/en/docs/twitter-api/annotations/overview
 *
 * NOTE: Under the assumption that we could always recover the `description`
 * of the domain and entity, this information is not stored to save space.
 */
export type ContextAnnotation = {
  domain_id: string;
  domain_name: string;
  entity_id: string;
  entity_name: string;
};

export type DehydratedAnnotationTracker = {
  annotation_tracking_id?: string | null;
  name: string;
};

export type DehydratedAssignment = {
  assignment_id: string;
  user_id: string;
  item_id: string;
  username: string;
  status: AssignmentStatus;
  order: number;
};

export type DehydratedPriorityModel = {
  priority_id?: string | null;
  project_id?: string | null;
  name?: string | null;
  time_created?: string | null;
  time_started?: string | null;
  time_ready?: string | null;
  time_assigned?: string | null;
  num_prioritised?: number | null;
};

export type DehydratedUser = {
  user_id?: string | null;
  username?: string | null;
  full_name?: string | null;
};

export type Event = {
  event: "ExampleSubEvent" | "ExampleEvent";
  payload: ExampleSubEvent | ExampleEvent;
};

export type ExampleEvent = {
  payload_a: string;
};

export type ExampleSubEvent = {
  payload_a: string;
};

export type ExportRequest = {
  labels: Array<LabelOptions>;
  nql_filter?:
    | FieldFilter
    | FieldFilters
    | LabelFilterMulti
    | LabelFilterBool
    | LabelFilterInt
    | AssignmentFilter
    | AnnotationFilter
    | AbstractFilter
    | ImportFilter
    | MetaFilterBool
    | MetaFilterInt
    | MetaFilterStr
    | SubQuery
    | null;
  bot_annotation_metadata_ids?: Array<string> | null;
  assignment_scope_ids?: Array<string> | null;
  user_ids?: Array<string> | null;
  ignore_hierarchy?: boolean;
  ignore_repeat?: boolean;
};

export type FieldFilter = {
  filter?: "field";
  field: "title" | "abstract" | "pub_year" | "date" | "source";
  value: string | number;
  comp?: string | null;
};

export type FieldFilters = {
  filter?: "field_mul";
  field: "doi" | "item_id" | "openalex_id";
  values: Array<string>;
};

export type FileOnDisk = {
  path: string;
  size: number;
};

export type FlatLabel = {
  path: Array<Label>;
  repeat: number;
  path_key: string;
  parent_int?: number | null;
  parent_key?: string | null;
  parent_value?: number | null;
  name: string;
  hint?: string | null;
  key: string;
  required: boolean;
  max_repeat: number;
  kind: "bool" | "str" | "float" | "int" | "single" | "multi" | "intext";
  choices?: Array<FlatLabelChoice> | null;
};

export type FlatLabelChoice = {
  name: string;
  hint?: string | null;
  value: number;
};

export type FlattenedAnnotationSchemeLabel = {
  name: string;
  hint?: string | null;
  key: string;
  required: boolean;
  max_repeat: number;
  implicit_max_repeat: number;
  kind: "bool" | "str" | "float" | "int" | "single" | "multi" | "intext";
  choices?: Array<AnnotationSchemeLabelChoiceFlat> | null;
  parent_label?: string | null;
  parent_choice?: number | null;
};

export type FullLexisNexisItemModel = {
  item_id?: string | null;
  project_id?: string | null;
  type?: ItemType;
  time_edited?: string | null;
  text?: string | null;
  teaser?: string | null;
  authors?: Array<string> | null;
  sources?: Array<LexisNexisItemSourceModel> | null;
};

/**
 * Corresponds to db.models.items.generic.GenericItem
 */
export type GenericItemModel = {
  item_id?: string | null;
  project_id?: string | null;
  type?: ItemType;
  time_edited?: string | null;
  text?: string | null;
  meta: {
    [key: string]: unknown;
  };
};

export type HTTPValidationError = {
  detail?: Array<ValidationError>;
};

export type Hashtag = {
  start: number;
  end: number;
  tag: string;
};

/**
 * A highlighter can be used in a project to highlight tokens in text to make
 * it easier for users to annotate documents when certain keywords are highlighted.
 *
 * It is assumed, that a highlighter roughly corresponds to query terms.
 * Furthermore, keywords in a highlighter will typically be joined into
 * a regular expression group (e.g. "(keyword1|double keyword|wildcar.*)").
 *
 * Each matching group will be wrapped in a highlight span in the frontend.
 */
export type HighlighterModel = {
  highlighter_id: string;
  project_id: string;
  name: string;
  keywords: Array<string>;
  style?: string | null;
};

export type HistogramEntry = {
  bucket: string;
  num_items: number;
};

export type IEUUID = {
  incl: boolean;
  uuid: string;
};

export type ImportDetails = {
  import_id?: string | null;
  user_id?: string | null;
  project_id: string;
  name: string;
  description: string;
  type: string;
  time_created?: string | null;
  config?:
    | ScopusImport
    | ScopusAPIImport
    | AcademicItemImport
    | OpenAlexFileImport
    | OpenAlexSolrImport
    | WoSImport
    | null;
  revisions: Array<ImportRevisionModel>;
};

export type ImportFilter = {
  filter?: "import";
  import_ids: Array<IEUUID>;
};

export type ImportInfo = {
  import_id?: string | null;
  user_id?: string | null;
  project_id: string;
  name: string;
  description: string;
  type: string;
  time_created?: string | null;
  config?:
    | ScopusImport
    | ScopusAPIImport
    | AcademicItemImport
    | OpenAlexFileImport
    | OpenAlexSolrImport
    | WoSImport
    | null;
  num_revisions: number;
  num_items?: number | null;
};

export type ImportM2M = {
  import_id: string;
  item_id: string;
  type: M2MImportItemType;
  first_revision: number;
  latest_revision: number;
};

export type ImportModel = {
  import_id?: string | null;
  user_id?: string | null;
  project_id: string;
  name: string;
  description: string;
  type: string;
  time_created?: string | null;
  config?:
    | ScopusImport
    | ScopusAPIImport
    | AcademicItemImport
    | OpenAlexFileImport
    | OpenAlexSolrImport
    | WoSImport
    | null;
};

export type ImportRevisionDetails = {
  import_revision_id?: string | null;
  import_revision_counter: number;
  time_created: string;
  pipeline_task_id?: string | null;
  import_id?: string | null;
  num_items_retrieved?: number | null;
  num_items?: number | null;
  num_items_new?: number | null;
  num_items_updated?: number | null;
  num_items_removed?: number | null;
  task?: TaskModel | null;
};

export type ImportRevisionModel = {
  import_revision_id?: string | null;
  import_revision_counter: number;
  time_created: string;
  pipeline_task_id?: string | null;
  import_id?: string | null;
  num_items_retrieved?: number | null;
  num_items?: number | null;
  num_items_new?: number | null;
  num_items_updated?: number | null;
  num_items_removed?: number | null;
};

export type ItemAnnotation = {
  value_bool?: boolean | null;
  value_int?: number | null;
  value_float?: number | null;
  value_str?: string | null;
  multi_int?: Array<number> | null;
  annotation_id?: string | null;
  time_created?: string | null;
  time_updated?: string | null;
  assignment_id: string;
  user_id: string;
  item_id: string;
  annotation_scheme_id: string;
  snippet_id?: string | null;
  key: string;
  repeat?: number;
  parent?: string | null;
  path: Array<Label>;
  old?: AnnotationValue | null;
};

export type ItemType = "generic" | "twitter" | "academic" | "patents" | "lexis";

export type ItemWithCount = {
  item_id: string;
  num_total: number;
  num_open: number;
  num_partial: number;
  num_full: number;
};

/**
 * Convenience type (corresponding to internal type in db annotation_label).
 * For Annotation or BotAnnotation, this is the combination of their respective key, repeat value.
 *
 * Mainly used during resolving annotations.
 */
export type Label = {
  key: string;
  repeat: number;
  value?: number | null;
};

export type LabelCount = {
  num_items: number;
  key: string;
  value_bool?: boolean | null;
  value_int?: number | null;
  value_float?: number | null;
  value_str?: string | null;
  multi?: number | null;
};

export type LabelFilterBool = {
  scopes?: Array<string> | null;
  scheme?: string | null;
  users?: UsersFilter | null;
  repeats?: Array<number> | null;
  key: string;
  type: "user" | "bot" | "resolved";
  filter?: "label_bool";
  value_type?: "bool";
  comp?: "=";
  value_bool?: boolean | null;
};

export type LabelFilterInt = {
  scopes?: Array<string> | null;
  scheme?: string | null;
  users?: UsersFilter | null;
  repeats?: Array<number> | null;
  key: string;
  type: "user" | "bot" | "resolved";
  filter?: "label_int";
  value_type?: "int";
  value_int?: number | null;
  comp: string;
};

export type LabelFilterMulti = {
  scopes?: Array<string> | null;
  scheme?: string | null;
  users?: UsersFilter | null;
  repeats?: Array<number> | null;
  key: string;
  type: "user" | "bot" | "resolved";
  filter?: "label_multi";
  value_type?: "multi";
  multi_int?: Array<number> | null;
  comp: string;
};

export type LabelOptions = {
  key: string;
  options_int?: Array<number> | null;
  options_bool?: Array<boolean> | null;
  options_multi?: Array<number> | null;
  strings?: boolean | null;
};

export type LabelScope = {
  scope_id: string;
  name: string;
  scope_type: "H" | "R";
};

export type LexisNexisItemModel = {
  item_id?: string | null;
  project_id?: string | null;
  type?: ItemType;
  time_edited?: string | null;
  text?: string | null;
  teaser?: string | null;
  authors?: Array<string> | null;
};

export type LexisNexisItemSourceModel = {
  item_source_id?: string | null;
  item_id?: string | null;
  lexis_id: string;
  name?: string | null;
  title?: string | null;
  section?: string | null;
  jurisdiction?: string | null;
  location?: string | null;
  content_type?: string | null;
  published_at?: string | null;
  updated_at?: string | null;
  meta?: {
    [key: string]: unknown;
  } | null;
};

/**
 * This is a type to specify an entry in the many-to-many relation for items to imports.
 *
 * - An `explicit` m2m relation is used for cases where the import "explicitly" matched this item.
 * For example: A tweet or paper matched a keyword specified in the query
 * - An `implicit` m2m relation is used for cases where the import only "implicitly" includes this item.
 * For example: A tweet is part of the conversation that contained a specified keyword or an
 * article that is referenced by an article that is included "explicitly" in the query.
 */
export type M2MImportItemType = "explicit" | "implicit";

export type Mention = {
  start: number;
  end: number;
  username: string;
  user_id: string | number;
};

export type MetaFilterBool = {
  field: string;
  filter?: "meta_bool";
  value_type?: "bool";
  comp?: "=";
  value: boolean;
};

export type MetaFilterInt = {
  field: string;
  filter?: "meta_int";
  value_type?: "int";
  comp: string;
  value: number;
};

export type MetaFilterStr = {
  field: string;
  filter?: "meta_str";
  value_type?: "str";
  comp?: "LIKE";
  value: string;
};

export type OpenAlexFileImport = {
  sources: Array<string>;
  kind?: "oa-file";
};

export type OpenAlexSolrImport = {
  kind?: "oa-solr";
  query: string;
  def_type?: "edismax" | "lucene" | "dismax";
  field?: "title" | "abstract" | "title_abstract";
  op?: "OR" | "AND";
};

export type PrioTableParams = {
  scope_ids: Array<string>;
  incl?: string;
  query?:
    | FieldFilter
    | FieldFilters
    | LabelFilterMulti
    | LabelFilterBool
    | LabelFilterInt
    | AssignmentFilter
    | AnnotationFilter
    | AbstractFilter
    | ImportFilter
    | MetaFilterBool
    | MetaFilterInt
    | MetaFilterStr
    | SubQuery
    | null;
  limit?: number;
};

export type PriorityModel = {
  priority_id?: string | null;
  project_id?: string | null;
  name?: string | null;
  time_created?: string | null;
  time_started?: string | null;
  time_ready?: string | null;
  time_assigned?: string | null;
  source_scopes?: Array<string> | null;
  nql?: string | null;
  nql_parsed?:
    | FieldFilter
    | FieldFilters
    | LabelFilterMulti
    | LabelFilterBool
    | LabelFilterInt
    | AssignmentFilter
    | AnnotationFilter
    | AbstractFilter
    | ImportFilter
    | MetaFilterBool
    | MetaFilterInt
    | MetaFilterStr
    | SubQuery
    | null;
  incl_rule?: string | null;
  incl_field?: string | null;
  incl_pred_field?: string | null;
  train_split?: number | null;
  n_predictions?: number | null;
  config?: SciBERTModel | ClimateBERTModel | RegressionModel | SVMModel | null;
  prioritised_ids?: Array<string> | null;
};

export type ProjectBaseInfo = {
  users: Array<ProjectBaseInfoEntry>;
  scopes: Array<ProjectBaseInfoScopeEntry>;
  bot_scopes: Array<ProjectBaseInfoEntry>;
  labels: {
    [key: string]: LabelOptions;
  };
};

export type ProjectBaseInfoEntry = {
  id: string;
  name: string;
};

export type ProjectBaseInfoScopeEntry = {
  id: string;
  name: string;
  scheme_id: string;
  scheme_name: string;
};

export type ProjectInfo = {
  project_id?: string | null;
  name: string;
  description?: string | null;
  time_created?: string | null;
  type: "generic" | "twitter" | "academic" | "patents" | "lexis" | ItemType;
  import_mutex?: boolean | null;
  setting_motivational_quotes?: boolean;
  owners: Array<UserBaseModel>;
};

/**
 * Project is the basic structural and conceptual place around which all functionality evolves.
 * It is essentially a container for a logically connected set of analyses, e.g. all work for a paper.
 *
 * Although Items (and subsequently their type-specific extensions) live outside the scope of a project,
 * they way they are augmented by annotations and analysis outcomes is always constrained to the scope
 * of a Project.
 */
export type ProjectModel = {
  project_id?: string | null;
  name: string;
  description?: string | null;
  time_created?: string | null;
  type: "generic" | "twitter" | "academic" | "patents" | "lexis" | ItemType;
  import_mutex?: boolean | null;
  setting_motivational_quotes?: boolean;
};

/**
 * ProjectPermissions allows to define fine-grained project-level permission management.
 * Once such an entry exists, the user is assumed to have very basic access to the respective project.
 * A user may become "owner" of a project, which will allow them to do everything and effectively ignoring the
 * other more fine-grained permission settings.
 *
 * It is assumed, that a user can always see and edit their own contributions (e.g. annotations) but
 * by giving them permission to view annotations, they can also see other users' annotations.
 */
export type ProjectPermissionsModel = {
  project_permission_id?: string | null;
  project_id: string;
  user_id: string;
  owner?: boolean;
  dataset_read?: boolean;
  dataset_edit?: boolean;
  imports_read?: boolean;
  imports_edit?: boolean;
  annotations_read?: boolean;
  annotations_edit?: boolean;
  annotations_prio?: boolean;
  pipelines_read?: boolean;
  pipelines_edit?: boolean;
  artefacts_read?: boolean;
  artefacts_edit?: boolean;
  search_dimensions?: boolean;
  search_oa?: boolean;
  import_limit_oa?: number;
};

export type QueryResult = {
  n_docs: number;
  docs: Array<AcademicItemModel> | Array<FullLexisNexisItemModel> | Array<GenericItemModel>;
};

export type RankEntry = {
  user_id: string;
  username: string;
  full_name: string;
  email: string;
  affiliation: string;
  num_labels: number;
  num_labeled_items: number;
};

export type ReferencedTweet = {
  id: string | number;
  type: "retweeted" | "quoted" | "replied_to";
};

export type RegressionModel = {
  stop_words?: "english" | Array<string> | null;
  ngram_range?: unknown[];
  max_df?: number;
  min_df?: number;
  max_features?: number | null;
  conf?: "REG";
};

export type ResolutionCell = {
  labels: {
    [key: string]: Array<ResolutionUserEntry>;
  };
  resolution: BotAnnotationModel;
  status?: ResolutionStatus;
};

export type ResolutionMethod = "majority" | "first";

export type ResolutionOrdering = {
  identifier: number;
  first_occurrence: number;
  item_id: string;
};

export type ResolutionProposal = {
  scheme_info: AnnotationSchemeInfo;
  labels: Array<FlatLabel>;
  annotators: Array<UserModel>;
  ordering: Array<ResolutionOrdering>;
  matrix: {
    [key: string]: {
      [key: string]: ResolutionCell;
    };
  };
};

export type ResolutionSnapshotEntry = {
  order_key: string;
  path_key: string;
  ba_id: string;
};

export type ResolutionStatus = "NEW" | "CHANGED" | "UNCHANGED";

export type ResolutionUserEntry = {
  assignment?: DehydratedAssignment | null;
  annotation?: ItemAnnotation | null;
  status?: ResolutionStatus;
};

export type SVMModel = {
  stop_words?: "english" | Array<string> | null;
  ngram_range?: unknown[];
  max_df?: number;
  min_df?: number;
  max_features?: number | null;
  conf?: "SVM";
  C?: number;
  kernel?: "linear" | "poly" | "rbf" | "sigmoid" | "precomputed";
  degree?: number;
};

export type SampleResponse = {
  data: Array<{
    [key: string]: unknown;
  }>;
  n_total: number;
  n_incl: number;
  n_excl: number;
};

export type SavedResolution = {
  meta: BotAnnotationResolution;
  proposal: ResolutionProposal;
};

export type SciBERTModel = {
  max_len?: number;
  train_split?: number;
  n_epochs?: number;
  batch_size_predict?: number;
  batch_size_train?: number;
  batch_size_eval?: number;
  warmup_steps?: number;
  weight_decay?: number;
  logging_steps?: number;
  eval_strategy?: string;
  eval_steps?: number;
  conf?: "SCIBERT";
  model?: string;
};

export type ScopusAPIImport = {
  kind?: "scopus-api";
  file: string;
  file_date: string;
  query: string;
  date: string;
};

export type ScopusImport = {
  sources: Array<string>;
  kind?: "scopus";
};

export type SearchPayload = {
  query: string;
  limit?: number;
  offset?: number;
  def_type?: "edismax" | "lucene" | "dismax";
  field?: "title" | "abstract" | "title_abstract";
  histogram?: boolean;
  op?: "OR" | "AND";
  histogram_from?: number;
  histogram_to?: number;
};

export type SearchResult = {
  query_time: number;
  num_found: number;
  docs: Array<AcademicItemModel>;
  histogram?: {
    [key: string]: number;
  } | null;
};

export type SnapshotEntry = {
  value_bool?: boolean | null;
  value_int?: number | null;
  value_float?: number | null;
  value_str?: string | null;
  multi_int?: Array<number> | null;
  order_key: string;
  path_key: string;
  item_id: string;
  anno_id: string;
  user_id: string;
};

export type SubQuery = {
  filter?: "sub";
  and_?: Array<
    | FieldFilter
    | FieldFilters
    | LabelFilterMulti
    | LabelFilterBool
    | LabelFilterInt
    | AssignmentFilter
    | AnnotationFilter
    | AbstractFilter
    | ImportFilter
    | MetaFilterBool
    | MetaFilterInt
    | MetaFilterStr
    | SubQuery
  > | null;
  or_?: Array<
    | FieldFilter
    | FieldFilters
    | LabelFilterMulti
    | LabelFilterBool
    | LabelFilterInt
    | AssignmentFilter
    | AnnotationFilter
    | AbstractFilter
    | ImportFilter
    | MetaFilterBool
    | MetaFilterInt
    | MetaFilterStr
    | SubQuery
  > | null;
  not_?:
    | FieldFilter
    | FieldFilters
    | LabelFilterMulti
    | LabelFilterBool
    | LabelFilterInt
    | AssignmentFilter
    | AnnotationFilter
    | AbstractFilter
    | ImportFilter
    | MetaFilterBool
    | MetaFilterInt
    | MetaFilterStr
    | SubQuery
    | null;
};

export type TaskModel = {
  task_id?: string | null;
  function_name: string;
  user_id?: string | null;
  project_id?: string | null;
  message_id?: string | null;
  comment?: string | null;
  params?:
    | {
        [key: string]: unknown;
      }
    | string
    | null;
  fingerprint: string;
  time_created?: string | null;
  time_started?: string | null;
  time_finished?: string | null;
  rec_expunge?: string | null;
  status?: TaskStatus;
};

export type TaskStatus = "PENDING" | "RUNNING" | "COMPLETED" | "FAILED" | "CANCELLED";

export type TermStats = {
  term: string;
  df: number;
  ttf: number;
};

/**
 * Corresponds to db.models.items.TwitterItem
 *
 * For more in-depth documentation, please refer to:
 * https://developer.twitter.com/en/docs/twitter-api/data-dictionary/object-model/tweet
 */
export type TwitterItemModel = {
  item_id?: string | null;
  project_id?: string | null;
  type?: ItemType;
  time_edited?: string | null;
  text?: string | null;
  twitter_id?: string | null;
  twitter_author_id?: string | null;
  created_at: string;
  language?: string | null;
  conversation_id?: string | null;
  referenced_tweets?: Array<ReferencedTweet> | null;
  latitude?: number | null;
  longitude?: number | null;
  hashtags?: Array<Hashtag> | null;
  mentions?: Array<Mention> | null;
  urls?: Array<URL> | null;
  cashtags?: Array<Cashtag> | null;
  context_annotations?: Array<ContextAnnotation> | null;
  retweet_count: number;
  reply_count: number;
  like_count: number;
  quote_count: number;
  user?: TwitterUserModel | null;
};

/**
 * Flattened and reduced representation of a Twitter User Object
 * https://developer.twitter.com/en/docs/twitter-api/data-dictionary/object-model/user
 *
 * NOTE:
 * - In the context of a `TwitterItemModel`, the `id` is not set as it can be inferred from `twitter_author_id`
 * - `name` is None if `name` == `username` to save space
 */
export type TwitterUserModel = {
  id?: string | null;
  created_at: string;
  name?: string | null;
  username: string;
  verified: boolean;
  description?: string | null;
  location?: string | null;
  followers_count?: number | null;
  following_count?: number | null;
  tweet_count?: number | null;
  listed_count?: number | null;
};

export type URL = {
  start: number;
  end: number;
  url: string;
  url_expanded: string;
};

/**
 * User represents a person.
 * Most entries in the database will be (indirectly) linked to user accounts, so this is
 * at the core of access management and ownership.
 */
export type UserBaseModel = {
  user_id?: string | null;
  username?: string | null;
  full_name?: string | null;
  email?: string | null;
  affiliation?: string | null;
  is_superuser?: boolean | null;
  is_active?: boolean | null;
  setting_newsletter?: boolean | null;
  time_created?: string | null;
  time_updated?: string | null;
};

export type UserInDBModel = {
  user_id?: string | null;
  username?: string | null;
  full_name?: string | null;
  email?: string | null;
  affiliation?: string | null;
  is_superuser?: boolean | null;
  is_active?: boolean | null;
  setting_newsletter?: boolean | null;
  time_created?: string | null;
  time_updated?: string | null;
  password?: string | null;
};

export type UserModel = {
  user_id?: string | null;
  username?: string | null;
  full_name?: string | null;
  email?: string | null;
  affiliation?: string | null;
  is_superuser?: boolean | null;
  is_active?: boolean | null;
  setting_newsletter?: boolean | null;
  time_created?: string | null;
  time_updated?: string | null;
};

export type UserPermission = {
  project_permission_id?: string | null;
  project_id: string;
  user_id: string;
  owner?: boolean;
  dataset_read?: boolean;
  dataset_edit?: boolean;
  imports_read?: boolean;
  imports_edit?: boolean;
  annotations_read?: boolean;
  annotations_edit?: boolean;
  annotations_prio?: boolean;
  pipelines_read?: boolean;
  pipelines_edit?: boolean;
  artefacts_read?: boolean;
  artefacts_edit?: boolean;
  search_dimensions?: boolean;
  search_oa?: boolean;
  import_limit_oa?: number;
  user: UserBaseModel;
};

export type UserProjectAssignmentScope = {
  scope: AssignmentScopeModel;
  scheme_name: string;
  scheme_description: string;
  num_assignments: number;
  num_open: number;
  num_partial: number;
  num_completed: number;
};

export type UsersFilter = {
  user_ids: Array<string>;
  mode: "ALL" | "ANY";
};

export type ValidationError = {
  loc: Array<string | number>;
  msg: string;
  type: string;
};

export type WoSImport = {
  sources: Array<string>;
  kind?: "wos";
};

export type $OpenApiTs = {
  "/api/ping/tracked-sleep-task": {
    get: {
      req: {
        sleepTime?: number;
      };
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/ping/sleep-task": {
    get: {
      req: {
        sleepTime?: number;
      };
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/ping/": {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: string;
      };
    };
  };
  "/api/ping/error": {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: string;
      };
    };
  };
  "/api/ping/warn": {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: string;
      };
    };
  };
  "/api/ping/permission": {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: unknown;
      };
    };
  };
  "/api/ping/database": {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: unknown;
      };
    };
  };
  "/api/ping/{name}": {
    post: {
      req: {
        name: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: string;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/annotations/schemes/definition/{annotation_scheme_id}": {
    get: {
      req: {
        annotationSchemeId: string;
        flat?: boolean;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: AnnotationSchemeModelFlat | AnnotationSchemeModel;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/annotations/schemes/definition/": {
    put: {
      req: {
        requestBody: AnnotationSchemeModel;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: string;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/annotations/schemes/definition/{scheme_id}": {
    delete: {
      req: {
        annotationSchemeId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/annotations/schemes/list": {
    get: {
      req: {
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: Array<AnnotationSchemeModel>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/annotations/schemes/fingerprints": {
    get: {
      req: {
        merged?: boolean;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200:
          | string
          | {
              [key: string]: string;
            };
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/annotations/annotate/next/{assignment_scope_id}/{current_assignment_id}": {
    get: {
      req: {
        assignmentScopeId: string;
        currentAssignmentId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: AnnotationItem;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/annotations/annotate/next/{assignment_scope_id}": {
    get: {
      req: {
        assignmentScopeId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: AnnotationItem;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/annotations/annotate/assignment/{assignment_id}": {
    get: {
      req: {
        assignmentId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: AnnotationItem;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/annotations/assignments/scopes/{project_id}": {
    get: {
      req: {
        projectId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: Array<UserProjectAssignmentScope>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/annotations/assignments/scopes/": {
    get: {
      req: {
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: Array<AssignmentScopeModel>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/annotations/assignments/scope/{assignment_scope_id}": {
    get: {
      req: {
        assignmentScopeId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: AssignmentScopeModel | null;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/annotations/assignments/scope/": {
    put: {
      req: {
        requestBody: AssignmentScopeModel;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/annotations/annotate/scope/{assignment_scope_id}": {
    delete: {
      req: {
        assignmentScopeId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/annotations/annotate/scope/counts/{assignment_scope_id}": {
    get: {
      req: {
        assignmentScopeId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: AssignmentCounts;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/annotations/annotate/assignments/{assignment_scope_id}": {
    get: {
      req: {
        assignmentScopeId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: Array<AssignmentModel>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/annotations/annotate/assignment/progress/{assignment_scope_id}": {
    get: {
      req: {
        assignmentScopeId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: Array<AssignmentScopeEntry>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/annotations/annotate/assignments/scope/{assignment_scope_id}": {
    get: {
      req: {
        assignmentScopeId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: Array<AssignmentModel>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/annotations/annotate/annotations/{assignment_scope_id}": {
    get: {
      req: {
        assignmentScopeId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: Array<AssignmentModel>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/annotations/annotate/save": {
    post: {
      req: {
        requestBody: AnnotatedItem;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: AssignmentStatus;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/annotations/config/items/": {
    get: {
      req: {
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: Array<ItemWithCount>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/annotations/config/assignments/{assignment_scope_id}": {
    put: {
      req: {
        assignmentScopeId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/annotations/config/scopes/clear/{scheme_id}": {
    post: {
      req: {
        scopeId: string;
        userId?: string | null;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/annotations/config/scopes/bulk-add/": {
    put: {
      req: {
        requestBody: BulkAddPayload;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/annotations/config/assignments/edit/": {
    put: {
      req: {
        requestBody: AssignmentEditInfo;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: AssignmentModel;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/annotations/config/scopes/{scheme_id}": {
    get: {
      req: {
        schemeId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: Array<AssignmentScopeModel>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/annotations/config/annotators/{scheme_id}": {
    get: {
      req: {
        schemeId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: Array<UserModel>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/annotations/config/resolve": {
    post: {
      req: {
        assignmentScopeId?: string | null;
        botAnnotationMetadatId?: string | null;
        includeEmpty?: boolean;
        includeNew?: boolean;
        requestBody: BotMetaResolveBase;
        updateExisting?: boolean;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: ResolutionProposal;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/annotations/config/resolved/{bot_annotation_metadata_id}": {
    get: {
      req: {
        botAnnotationMetadataId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: SavedResolution;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/annotations/config/resolve/": {
    put: {
      req: {
        annotationSchemeId: string;
        assignmentScopeId: string;
        name: string;
        requestBody: Body_save_resolved_annotations_api_annotations_config_resolve__put;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: string;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/annotations/config/resolve/update": {
    put: {
      req: {
        botAnnotationMetadataId: string;
        name: string;
        requestBody: {
          [key: string]: {
            [key: string]: ResolutionCell;
          };
        };
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/annotations/config/resolved-list/": {
    get: {
      req: {
        annotationSchemeId?: string | null;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: Array<BotAnnotationMetaDataBaseModel>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/annotations/config/resolved/{bot_annotation_meta_id}": {
    delete: {
      req: {
        botAnnotationMetadataId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/annotations/bot/annotations": {
    get: {
      req: {
        includeResolve?: boolean;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: Array<BotMetaInfo>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/annotations/bot/scopes": {
    get: {
      req: {
        onlyResolve?: boolean;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: Array<BotAnnotationMetaDataModel>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/users/list/all": {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: Array<UserBaseModel>;
      };
    };
  };
  "/api/users/list/all/dehydrated": {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: Array<DehydratedUser>;
      };
    };
  };
  "/api/users/list/project/annotators/{project_id}": {
    get: {
      req: {
        projectId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: {
          [key: string]: UserBaseModel;
        };
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/users/list/project/{project_id}": {
    get: {
      req: {
        projectId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: Array<UserBaseModel>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/users/details/{user_id}": {
    get: {
      req: {
        userId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: UserModel;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/users/details": {
    get: {
      req: {
        userId: Array<string>;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: Array<UserModel>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    put: {
      req: {
        requestBody: UserInDBModel | UserModel;
      };
      res: {
        /**
         * Successful Response
         */
        200: string;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/users/my-details": {
    put: {
      req: {
        requestBody: UserInDBModel | UserModel;
      };
      res: {
        /**
         * Successful Response
         */
        200: string;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/login/token": {
    post: {
      req: {
        formData: Body_login_for_access_token_api_login_token_post;
      };
      res: {
        /**
         * Successful Response
         */
        200: AuthTokenModel;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/login/token/{token_id}": {
    put: {
      req: {
        tokenId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: AuthTokenModel;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: {
        tokenId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/login/my-tokens": {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: Array<AuthTokenModel>;
      };
    };
  };
  "/api/login/me": {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: UserModel;
      };
    };
  };
  "/api/login/logout": {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: unknown;
      };
    };
  };
  "/api/projects/list": {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: Array<ProjectInfo>;
      };
    };
  };
  "/api/projects/create": {
    put: {
      req: {
        requestBody: ProjectModel;
      };
      res: {
        /**
         * Successful Response
         */
        200: string;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/project/info": {
    get: {
      req: {
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: ProjectModel;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    put: {
      req: {
        requestBody: ProjectModel;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: string;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/project/import_mutex": {
    put: {
      req: {
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/project/permissions/me": {
    get: {
      req: {
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: ProjectPermissionsModel;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/project/permissions/list/{project_id}": {
    get: {
      req: {
        projectId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: Array<ProjectPermissionsModel>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/project/permissions/list-users": {
    get: {
      req: {
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: Array<UserPermission>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/project/permissions/permission": {
    put: {
      req: {
        requestBody: ProjectPermissionsModel;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: string;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: {
        projectPermissionId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/project/permissions/{project_permission_id}": {
    get: {
      req: {
        projectPermissionId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: ProjectPermissionsModel;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/project/items/{item_type}/list": {
    get: {
      req: {
        itemType: "generic" | "twitter" | "academic" | "patents" | "lexis";
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200:
          | Array<TwitterItemModel>
          | Array<AcademicItemModel>
          | Array<LexisNexisItemModel>
          | Array<FullLexisNexisItemModel>
          | Array<GenericItemModel>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/project/items/{item_type}/list/{page}/{page_size}": {
    get: {
      req: {
        itemType: "generic" | "twitter" | "academic" | "patents" | "lexis";
        page: number;
        pageSize: number;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200:
          | Array<TwitterItemModel>
          | Array<AcademicItemModel>
          | Array<LexisNexisItemModel>
          | Array<FullLexisNexisItemModel>
          | Array<GenericItemModel>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/project/items/detail/{item_id}": {
    get: {
      req: {
        itemId: string;
        itemType?: "generic" | "twitter" | "academic" | "patents" | "lexis" | null;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: TwitterItemModel | AcademicItemModel | LexisNexisItemModel | FullLexisNexisItemModel | GenericItemModel;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/project/items/text/{item_id}": {
    get: {
      req: {
        itemId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: string;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/project/items/count": {
    get: {
      req: {
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: number;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/project/items/twitter/add": {
    post: {
      req: {
        importId?: string | null;
        requestBody: TwitterItemModel;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/imports/list": {
    get: {
      req: {
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: Array<ImportInfo>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/imports/list/details": {
    get: {
      req: {
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: Array<ImportDetails>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/imports/import/{import_id}": {
    get: {
      req: {
        importId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: ImportModel;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    post: {
      req: {
        importId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/imports/import/{import_id}/count/": {
    get: {
      req: {
        importId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: number;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/imports/import/{import_id}/revisions": {
    get: {
      req: {
        importId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: Array<ImportRevisionDetails>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/imports/import": {
    put: {
      req: {
        requestBody: ImportModel;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: string;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/imports/import/delete/{import_id}": {
    delete: {
      req: {
        importId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: string;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/events/emit": {
    post: {
      req: {
        requestBody: Event;
      };
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/highlighters/project": {
    get: {
      req: {
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: Array<HighlighterModel>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    put: {
      req: {
        requestBody: HighlighterModel;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: string;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/highlighters/{highlighter_id}": {
    get: {
      req: {
        highlighterId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: HighlighterModel | null;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/stats/basics": {
    get: {
      req: {
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: BasicProjectStats;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/stats/rank": {
    get: {
      req: {
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: Array<RankEntry>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/stats/histogram/years": {
    get: {
      req: {
        fromYear?: number;
        toYear?: number;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: Array<HistogramEntry>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/stats/labels": {
    post: {
      req: {
        requestBody?:
          | FieldFilter
          | FieldFilters
          | LabelFilterMulti
          | LabelFilterBool
          | LabelFilterInt
          | AssignmentFilter
          | AnnotationFilter
          | AbstractFilter
          | ImportFilter
          | MetaFilterBool
          | MetaFilterInt
          | MetaFilterStr
          | SubQuery
          | null;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: Array<LabelCount>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/export/annotations/csv": {
    post: {
      req: {
        requestBody: ExportRequest;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: string;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/export/project/baseinfo": {
    get: {
      req: {
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: ProjectBaseInfo;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/search/openalex/select": {
    post: {
      req: {
        requestBody: SearchPayload;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: SearchResult;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/search/openalex/terms": {
    get: {
      req: {
        limit?: number;
        termPrefix: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: Array<TermStats>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/search/nql/query": {
    post: {
      req: {
        limit?: number;
        page?: number;
        requestBody:
          | FieldFilter
          | FieldFilters
          | LabelFilterMulti
          | LabelFilterBool
          | LabelFilterInt
          | AssignmentFilter
          | AnnotationFilter
          | AbstractFilter
          | ImportFilter
          | MetaFilterBool
          | MetaFilterInt
          | MetaFilterStr
          | SubQuery;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: QueryResult;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/search/nql/count": {
    post: {
      req: {
        requestBody?:
          | FieldFilter
          | FieldFilters
          | LabelFilterMulti
          | LabelFilterBool
          | LabelFilterInt
          | AssignmentFilter
          | AnnotationFilter
          | AbstractFilter
          | ImportFilter
          | MetaFilterBool
          | MetaFilterInt
          | MetaFilterStr
          | SubQuery
          | null;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: number;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/eval/tracking/scopes": {
    get: {
      req: {
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: Array<LabelScope>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/eval/resolutions": {
    get: {
      req: {
        assignmentScopeId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: Array<BotAnnotationMetaDataBaseModel>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/eval/tracking/trackers": {
    get: {
      req: {
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: Array<DehydratedAnnotationTracker>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/eval/tracking/tracker/{tracker_id}": {
    get: {
      req: {
        trackerId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: AnnotationTrackerModel;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/eval/tracking/tracker": {
    put: {
      req: {
        requestBody: AnnotationTrackerModel;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: string;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/eval/tracking/refresh": {
    post: {
      req: {
        reset?: boolean;
        trackerId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: AnnotationTrackerModel;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/eval/quality/load/{assignment_scope_id}": {
    get: {
      req: {
        assignmentScopeId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: Array<AnnotationQualityModel>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/eval/quality/compute": {
    get: {
      req: {
        assignmentScopeId: string;
        botAnnotationMetadataId?: string | null;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: Array<AnnotationQualityModel>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/mail/reset-password/{username}": {
    post: {
      req: {
        username: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: string;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/mail/welcome": {
    post: {
      req: {
        password: string;
        username: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: string;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/mail/assignment-reminder": {
    post: {
      req: {
        assignmentScopeId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: Array<string>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/mail/news": {
    post: {
      req: {
        isActive?: boolean | null;
        isSubscribed?: boolean | null;
        requestBody: Body_news_mail_api_mail_news_post;
      };
      res: {
        /**
         * Successful Response
         */
        200: Array<string>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/pipes/artefacts/list": {
    get: {
      req: {
        xProjectId: string;
        xTaskId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: Array<FileOnDisk>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/pipes/artefacts/log": {
    get: {
      req: {
        xProjectId: string;
        xTaskId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: string;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/pipes/artefacts/log-stream": {
    get: {
      req: {
        xProjectId: string;
        xTaskId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/pipes/artefacts/file": {
    get: {
      req: {
        filename: string;
        xProjectId: string;
        xTaskId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/pipes/artefacts/files": {
    get: {
      req: {
        xProjectId: string;
        xTaskId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/pipes/artefacts/files/upload": {
    post: {
      req: {
        folder?: string | null;
        formData: Body_upload_file_api_pipes_artefacts_files_upload_post;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: string;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/pipes/artefacts/files/upload-many": {
    post: {
      req: {
        folder?: string | null;
        formData: Body_upload_files_api_pipes_artefacts_files_upload_many_post;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: Array<string>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/pipes/tasks": {
    get: {
      req: {
        fingerprint?: string | null;
        functionName?: string | null;
        location?: string | null;
        orderByFields?: Array<string> | null;
        status?: TaskStatus | null;
        userId?: string | null;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: Array<TaskModel>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/pipes/task": {
    get: {
      req: {
        xProjectId: string;
        xTaskId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: TaskModel;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: {
        xProjectId: string;
        xTaskId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/pipes/dramatiq/task": {
    delete: {
      req: {
        messageId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/pipes/dramatiq/workers": {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: unknown;
      };
    };
  };
  "/api/pipes/dramatiq/tasks": {
    get: {
      res: {
        /**
         * Successful Response
         */
        200: unknown;
      };
    };
  };
  "/api/item/variants/{item_id}": {
    get: {
      req: {
        itemId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: Array<AcademicItemVariantModel>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/item/info/{item_id}": {
    get: {
      req: {
        itemId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: AcademicItemModel;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/item/m2ms/{item_id}": {
    get: {
      req: {
        itemId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: Array<ImportM2M>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/item/labels/{item_id}": {
    get: {
      req: {
        itemId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: unknown[];
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/item/info": {
    put: {
      req: {
        requestBody: AcademicItemModel;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/prio/table/peek/html": {
    post: {
      req: {
        requestBody: PrioTableParams;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: string;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/prio/table/peek": {
    post: {
      req: {
        requestBody: PrioTableParams;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: SampleResponse;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/prio/setups": {
    get: {
      req: {
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: Array<DehydratedPriorityModel>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/prio/setup": {
    get: {
      req: {
        priorityId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: PriorityModel | null;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    put: {
      req: {
        requestBody: PriorityModel;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
    delete: {
      req: {
        priorityId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/prio/artefacts/list": {
    get: {
      req: {
        xPriorityId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: Array<FileOnDisk>;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
  "/api/prio/artefacts/file": {
    get: {
      req: {
        filename: string;
        xPriorityId: string;
        xProjectId: string;
      };
      res: {
        /**
         * Successful Response
         */
        200: unknown;
        /**
         * Validation Error
         */
        422: HTTPValidationError;
      };
    };
  };
};
